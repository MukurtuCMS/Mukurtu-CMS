<?php

/**
 * @file
 * Provide Mukurtu Protocols (access control).
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\NodeInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\og\Og;
use Drupal\og\OgGroupAudienceHelperInterface;
use Drupal\og\Entity\OgMembership;
use Drupal\Core\Database\Query\AlterableInterface;
use Drupal\Core\Database\Query\Condition;
use Drupal\user\Entity\User;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\ReplaceCommand;
use Drupal\Core\Ajax\InvokeCommand;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;

define("MUKURTU_PROTOCOL_GRANTS_REALM", "mukurtu");
define("MUKURTU_PROTOCOL_PERSONAL", "personal");
define("MUKURTU_PROTOCOL_PUBLIC", "public");
define("MUKURTU_PROTOCOL_DEFAULT", "default");
define("MUKURTU_PROTOCOL_ANY", "any");
define("MUKURTU_PROTOCOL_ALL", "all");
define("MUKURTU_PROTOCOL_FIELD_NAME_COMMUNITY", "field_mukurtu_community");
define("MUKURTU_PROTOCOL_FIELD_NAME_MEMBERSHIP_HANDLER", "field_membership_handler");
define("MUKURTU_PROTOCOL_FIELD_NAME_READ", "field_mukurtu_protocol_read");
define("MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE", "field_mukurtu_protocol_r_scope");
define("MUKURTU_PROTOCOL_FIELD_NAME_WRITE", "field_mukurtu_protocol_write");
define("MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE", "field_mukurtu_protocol_w_scope");
define("MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET", "field_mukurtu_protocol_inherit");
define("MUKURTU_PROTOCOL_FIELD_NAME_READ_COMPUTED", "field_mukurtu_protocol_r_compute");
define("MUKURTU_PROTOCOL_FIELD_NAME_INHERIT_FIRST_USE", "field_mukurtu_protocol_inherit_first_use");

/**
 * Create the Mukurtu protocol field for a given node bundle type.
 */
function mukurtu_protocol_create_protocol_field($entity_type, $bundle_type) {
  // List of entity types/bundles that should never have protocol fields.
  $bundle_skip_list = ['node' => ['community', 'protocol'], 'comment' => ['comment_type']];
  // List of entity types/bundles that should never have write protocol fields.
  $write_bundle_skip_list = ['comment' => ['comment']];

  // Skip field creation completely if the entity/bundle is on the ban list.
  if (!empty($bundle_skip_list[$entity_type]) && in_array($bundle_type, $bundle_skip_list[$entity_type])) {
    return;
  }

  // What fields does this entity/bundle already have?
  $entityFieldManager = \Drupal::service('entity_field.manager');
  $fields = $entityFieldManager->getFieldDefinitions($entity_type, $bundle_type);

  // Read Access Protocol Field.
  $settings['field_name'] = MUKURTU_PROTOCOL_FIELD_NAME_READ;
  $settings['field_config']['label'] = "Mukurtu Protocol - View Access";
  $settings['field_config']['description'] = "Mukurtu Protocol Helper Text Goes Here";
  $settings['field_config']['handler'] = 'default';
  $settings['field_config']['handler_settings']['target_bundles'] = ['protocol'];
  $settings['field_storage_config']['target_type'] = "node";
  if (!isset($fields[MUKURTU_PROTOCOL_FIELD_NAME_READ])) {
    Og::createField(OgGroupAudienceHelperInterface::DEFAULT_FIELD, $entity_type, $bundle_type, $settings);
  }

  // OG doesn't actually use the field settings we give it.
  // We will set the protocol fields to target protocols only here.
  $field_config = FieldConfig::loadByName($entity_type, $bundle_type, MUKURTU_PROTOCOL_FIELD_NAME_READ);
  $field_config->setSettings($settings['field_config']);
  $field_config->save();
  $field_storage_config = FieldStorageConfig::loadByName($entity_type, MUKURTU_PROTOCOL_FIELD_NAME_READ);
  if ($field_storage_config) {
    $field_storage_config->setSetting('target_type', 'node');
    $field_storage_config->save();
  }

  // Read Access Protocol Scope Field.
  if (!isset($fields[MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE])) {
    $field = FieldConfig::create([
      'field_name' => MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE,
      'entity_type' => $entity_type,
      'bundle' => $bundle_type,
      'label' => 'Mukurtu Protocol - View Scope',
    ]);
    $field->save();
  }

  if (empty($write_bundle_skip_list[$entity_type]) || !in_array($bundle_type, $write_bundle_skip_list[$entity_type])) {
    // Write Access Protocol Field.
    $settings['field_name'] = MUKURTU_PROTOCOL_FIELD_NAME_WRITE;
    $settings['field_config']['label'] = "Mukurtu Protocol - Update Access";
    $settings['field_config']['description'] = "Mukurtu Protocol Helper Text Goes Here";
    $settings['field_config']['handler'] = 'default';
    $settings['field_config']['handler_settings']['target_bundles'] = ['protocol'];
    $settings['field_storage_config']['target_type'] = "node";
    if (!isset($fields[MUKURTU_PROTOCOL_FIELD_NAME_WRITE])) {
      Og::createField(OgGroupAudienceHelperInterface::DEFAULT_FIELD, $entity_type, $bundle_type, $settings);
    }

    // OG doesn't actually use the field settings we give it.
    // We will set the protocol fields to target protocols only here.
    $field_config = FieldConfig::loadByName($entity_type, $bundle_type, MUKURTU_PROTOCOL_FIELD_NAME_WRITE);
    $field_config->setSettings($settings['field_config']);
    $field_config->save();
    $field_storage_config = FieldStorageConfig::loadByName($entity_type, MUKURTU_PROTOCOL_FIELD_NAME_WRITE);
    if ($field_storage_config) {
      $field_storage_config->setSetting('target_type', 'node');
      $field_storage_config->save();
    }

    // Write Access Protocol Scope Field.
    if (!isset($fields[MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE])) {
      $field = FieldConfig::create([
        'field_name' => MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE,
        'entity_type' => $entity_type,
        'bundle' => $bundle_type,
        'label' => 'Mukurtu Protocol - Update Scope',
      ]);
      $field->save();
    }
  }

  // Protocol Inheritance Field.
  if (!isset($fields[MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET])) {
    $field = FieldConfig::create([
      'field_name' => MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET,
      'entity_type' => $entity_type,
      'bundle' => $bundle_type,
      'label' => 'Mukurtu Protocol - Inheritance Target',
    ]);
    $field->save();
  }
}

/**
 * Configure the given entity/bundle form to use the custom protocol widgets.
 */
function mukurtu_protocol_use_custom_protocol_widgets($entity_type, $bundle_type) {
  // Use our custom widgets in the form display.
  // Read fields widgets.
  $read = \Drupal::entityTypeManager()
    ->getStorage('entity_form_display')
    ->load("{$entity_type}.{$bundle_type}.default");
  if ($read) {
    $read->setComponent(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE, [
      'type' => 'mukurtu_protocol_scope_widget',
      'region' => 'content',
      'weight' => -6,
    ])
    ->setComponent(MUKURTU_PROTOCOL_FIELD_NAME_READ, [
      'type' => 'mukurtu_protocol_widget',
      'region' => 'content',
      'weight' => -5,
    ])
    ->setComponent('title', [
      'weight' => -7,
    ])
    ->setComponent('name', [
      'weight' => -8,
    ])
    ->save();
  }

  // Write fields widgets.
  $write = \Drupal::entityTypeManager()
    ->getStorage('entity_form_display')
    ->load("{$entity_type}.{$bundle_type}.default");
  if ($write) {
    $write->setComponent(MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE, [
      'type' => 'mukurtu_protocol_scope_widget',
      'region' => 'content',
      'weight' => -4,
    ])
    ->setComponent(MUKURTU_PROTOCOL_FIELD_NAME_WRITE, [
      'type' => 'mukurtu_protocol_widget',
      'region' => 'content',
      'weight' => -3,
    ])
    ->save();
  }
}

/**
 * Configure all nodes/media to use our protocol widget.
 */
function mukurtu_protocol_use_custom_protocol_widgets_sitewide() {
  // Create the protocol field on all pre-existing node types.
  foreach (node_type_get_names() as $bundle => $label) {
    mukurtu_protocol_use_custom_protocol_widgets('node', $bundle);
  }

  // Create the protocol field for all pre-existing media types.
  $entity_type_bundle = \Drupal::service('entity_type.bundle.info');
  $media_types = $entity_type_bundle->getBundleInfo('media');
  foreach ($media_types as $media_type => $media_label) {
    mukurtu_protocol_use_custom_protocol_widgets('media', $media_type);
  }
}

/**
 * Check if entity type is protocol enabled.
 */
function mukurtu_protocol_supported_entity_type($entity_type_id) {
  // Note: Eventually types might be configurable.
  switch ($entity_type_id) {
    case 'node':
    case 'media':
    case 'comment':
    case 'message':
      return TRUE;

    default:
      return FALSE;

  }
}

/**
 * Implements hook_entity_base_field_info().
 */
function mukurtu_protocol_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];
  if (mukurtu_protocol_supported_entity_type($entity_type->id())) {
    $fields[MUKURTU_PROTOCOL_FIELD_NAME_READ_COMPUTED] = BaseFieldDefinition::create('integer')
      ->setName(MUKURTU_PROTOCOL_FIELD_NAME_READ_COMPUTED)
      ->setLabel(t('Mukurtu Computed Protocol - Read'))
      ->setDescription(t('A computed field that stores the pre-calculated list of effective protocol groups.'))
      ->setComputed(TRUE)
      ->setClass('Drupal\mukurtu_protocol\Plugin\Field\MukurtuCalculatedProtocolField')
      ->setCardinality(-1)
      ->setDisplayConfigurable('view', FALSE);
  }
  return $fields;
}

/**
 * Implements hook_entity_access().
 */
function mukurtu_protocol_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {
  $type = $entity->getEntityTypeId();

  // Do not allow the deletion of communities that have attached protocols.
  if ($type == 'node' && $entity->bundle() == 'community' && $operation == 'delete') {
    $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
    $protocols = $protocol_manager->getCommunityProtocols($entity);

    if (count($protocols) > 0) {
      return AccessResult::forbidden();
    }
  }

  // Protocols only work with nodes & media.
  if (mukurtu_protocol_supported_entity_type($type)) {
    $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
    if ($protocol_manager->hasProtocolFields($entity)) {
      return $protocol_manager->checkAccess($entity, $operation, $account);
    }
  }

  return AccessResult::neutral();
}

/**
 * For a new entity, check if any referenced entities need
 * inheritance targets set.
 */
function mukurtu_protocol_resolve_new_content_inheritance($entity) {
  $referenced_entities = $entity->referencedEntities();
  foreach ($referenced_entities as $referenced_entity) {
    // Currently only handling media entities.
    if ($referenced_entity->getEntityTypeId() == 'media') {
      $scope = $referenced_entity->get(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE)->value;
      $target = $referenced_entity->get(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)->value;
      // If the media is set to personal AND not currently using inheritance,
      // assume that the user wants the media to inherit the content protocol.
      if (   $scope == MUKURTU_PROTOCOL_PERSONAL
          && $target == NULL
      ) {
        // Set the inheritance target to the owning content.
        $referenced_entity->set(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET, $entity->id());
        $referenced_entity->save();
      }
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function mukurtu_protocol_entity_insert(EntityInterface $entity) {
  // Update protocol tables.
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  if ($protocol_manager->hasProtocolFields($entity)) {
    // Handle post-save protocol inheritance for new items,
    // such as media being referenced by a DH item.
    mukurtu_protocol_resolve_new_content_inheritance($entity);

    // If the new item is using inheritance and the target is set,
    // do the protocol copy now.
    $inheritance_target_id = NULL;
    //if ($entity->hasField(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)) {
    if (isset($entity->get(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)[0])) {
      $inheritance_target_id = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)[0]->target_id;
      $inheritance_target = \Drupal::entityTypeManager()->getStorage('node')->load($inheritance_target_id);
      if ($inheritance_target) {
        $protocol_manager->copyProtocolFields($inheritance_target, $entity);
      }
    }
    //}

    if ($inheritance_target_id == NULL) {
      // Only run this if not doing inheritance. copyProtocolFields will
      // trigger hook_entity_update, which will run handleProtocolUpdate.
      $protocol_manager->handleProtocolUpdate($entity);
    }
  }

  // Handle OgMemberships from here on.
  if (!$entity instanceof OgMembership) {
    return;
  }

  $entity_type = $entity->get('entity_type')->value;
  $entity_bundle = $entity->get('entity_bundle')->value;

  // Handle user being added to a community.
  if ($entity_type == 'node' && $entity_bundle == 'community') {
    $uid = $entity->getOwnerId();
    $nid = $entity->get('entity_id')->value;
    $protocol_manager->processCommunityMembershipInsert($nid, $uid);
  }

  // Invalidate cache for content under the protocol with the membership change.
  if ($entity_type == 'node' && $entity_bundle == 'protocol') {
    $uid = $entity->getOwnerId();
    $nid = $entity->get('entity_id')->value;

    $protocol_manager->processProtocolMembershipInsert($nid, $uid);
    $protocol = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
    $protocol_manager->invalidateProtocolCache($protocol);
  }
}

/**
 * Implements hook_entity_update().
 */
function mukurtu_protocol_entity_update(EntityInterface $entity) {
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  if ($protocol_manager->hasProtocolFields($entity)) {
    // Handle post-save protocol inheritance for new items,
    // such as media being referenced by a DH item.
    mukurtu_protocol_resolve_new_content_inheritance($entity);

    $protocol_manager->handleProtocolUpdate($entity);

    // Protocol Inheritance.
    $protocol_manager->updateProtocolInheritance($entity);

    // Check for inheritance changes for this particular node.
    if (method_exists($entity, 'hasField') && $entity->hasField(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)) {
      $original_target_field = $entity->original->get(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)->first();
      $new_target_field = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET)->first();
      $original_target_id = is_null($original_target_field) ? NULL : $original_target_field->target_id;
      $new_target_id = is_null($new_target_field) ? NULL : $new_target_field->target_id;

      // Only update if there's been a change.
      if (!is_null($new_target_id) && $original_target_id != $new_target_id) {
        $inheritance_node = \Drupal::entityTypeManager()->getStorage('node')->load($new_target_id);
        $protocol_manager->updateProtocolInheritance($inheritance_node);
      }
    }
  }

  // Handle OgMemberships from here on.
  if (!$entity instanceof OgMembership) {
    return;
  }

  // Invalidate cache for content under the protocol with the membership change.
  if ($entity->get('entity_type')->value == 'node' && $entity->get('entity_bundle')->value == 'protocol') {
    $nid = $entity->get('entity_id')->value;
    $protocol = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
    $protocol_manager->invalidateProtocolCache($protocol);
  }
}

/**
 * Implements hook_entity_delete().
 */
function mukurtu_protocol_entity_delete(EntityInterface $entity) {
  // Clean up protocol entries for deleted entity.
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  if ($protocol_manager->hasProtocolFields($entity)) {
    // Protocol Inheritance.
    $protocol_manager->updateProtocolInheritance($entity, 'delete');
    $protocol_manager->clearProtocolAccess($entity);
  }

  // Handle OgMemberships from here on.
  if (!$entity instanceof OgMembership) {
    return;
  }

  // Handle user being removed from a community.
  if ($entity->get('entity_type')->value == 'node' && $entity->get('entity_bundle')->value == 'community') {
    $uid = $entity->getOwnerId();
    $nid = $entity->get('entity_id')->value;
    $protocol_manager->processCommunityMembershipDelete($nid, $uid);
  }

  // Invalidate cache for content under the protocol with the deleted membership.
  if ($entity->get('entity_type')->value == 'node' && $entity->get('entity_bundle')->value == 'protocol') {
    $nid = $entity->get('entity_id')->value;
    $protocol = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
    $protocol_manager->invalidateProtocolCache($protocol);
  }
}

/**
 * Implements hook_node_grants().
 */
function mukurtu_protocol_node_grants(AccountInterface $account, $op) {
  $grants = [];

  if ($op == 'view') {
    $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
    $grantIds = $protocol_manager->getUserGrantIds($account);
    $grants[MUKURTU_PROTOCOL_GRANTS_REALM] = $grantIds;
  }

  return $grants;
}

/**
 * Implements hook_node_access_records().
 */
function mukurtu_protocol_node_access_records(NodeInterface $node) {
  $view_mode = $node->hasField(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE) ? $node->get(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE)->value : 'none';
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  $protocols = $protocol_manager->getProtocols($node);

  $grants = [];

  // Author only.
  if ($view_mode == MUKURTU_PROTOCOL_PERSONAL) {
    $uid = $node->getOwnerId();
    $p_id = $protocol_manager->getProtocolGrantId([$uid], 'user');
    if ($p_id) {
      $grants[] = [
        'realm' => MUKURTU_PROTOCOL_GRANTS_REALM,
        'gid' => $p_id,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      ];
    }
  }

  // Public.
  if ($view_mode == MUKURTU_PROTOCOL_PUBLIC) {
    $p_id = $protocol_manager->getProtocolGrantId([], 'public');
    if ($p_id) {
      $grants[] = [
        'realm' => MUKURTU_PROTOCOL_GRANTS_REALM,
        'gid' => $p_id,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      ];
    }
  }

  // For "any" protocol, create a grant for each single ID.
  if ($view_mode == MUKURTU_PROTOCOL_ANY) {
    foreach ($protocols as $p) {
      $p_id = $protocol_manager->getProtocolGrantId([$p]);
      if ($p_id) {
        $grants[] = [
          'realm' => MUKURTU_PROTOCOL_GRANTS_REALM,
          'gid' => $p_id,
          'grant_view' => 1,
          'grant_update' => 0,
          'grant_delete' => 0,
          'priority' => 0,
        ];
      }
    }
  }

  // For "all" protocols, create a single grant for the effective protocol ID.
  if ($view_mode == MUKURTU_PROTOCOL_ALL) {
    $p_id = $protocol_manager->getProtocolGrantId($protocols);
    if ($p_id) {
      $grants[] = [
        'realm' => MUKURTU_PROTOCOL_GRANTS_REALM,
        'gid' => $p_id,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      ];
    }
  }

  return $grants;
}

/**
 * Implements hook_entity_bundle_create().
 */
function mukurtu_protocol_entity_bundle_create($entity_type_id, $bundle) {
  // For any new supported entity type that is defined, add the protocol field.
  if (mukurtu_protocol_supported_entity_type($entity_type_id)) {
    mukurtu_protocol_create_protocol_field($entity_type_id, $bundle);
    mukurtu_protocol_use_custom_protocol_widgets($entity_type_id, $bundle);
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function mukurtu_protocol_entity_type_alter(array &$entity_types) {
  //$entity_types['media']->setHandlerClass('access', '\Drupal\Core\Entity\EntityAccessControlHandler');
  //$entity_types['media']->setHandlerClass('query_access', '\Drupal\Core\Entity\QueryAccess\QueryAccessHandler');
  //$entity_types['media']->setHandlerClass('query_access', '\Drupal\entity\QueryAccess\QueryAccessHandler');
  //$entity_types['media']->setHandlerClass('permission_provider', '\Drupal\Core\Entity\EntityPermissionProvider');
}

/**
 * Implements hook_query_TAG_alter().
 */
function mukurtu_protocol_query_media_access_alter(AlterableInterface $query) {
  $account = User::load(\Drupal::currentUser()->id());
  if (is_null($account)) {
    $account = User::getAnonymousUser();
  }
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');

  // Protocol Set IDs the *user* has access to.
  $protocol_set_ids = $protocol_manager->getUserGrantIds($account);

  // Get the protocol set IDs for the media.
  //$query->leftJoin('mukurtu_protocol_access', 'mpa', 'media_field_data.mid = mpa.id');
  $media_tables = $query->getTables();
  $media_tables_keys = array_keys($media_tables);
  $media_table = reset($media_tables_keys);
  $query->leftJoin('mukurtu_protocol_access', 'mpa', "$media_table.mid = mpa.id");
  $query->condition('mpa.entity_type', 'media');

  if (empty($protocol_set_ids)) {
    // User doesn't have access to any protocols.
    $query->condition('protocol_set_id', 0);
  } else {
    // User can access media for any of these protocol sets.
    $or = new Condition('OR');
    foreach ($protocol_set_ids as $protocol_set_id) {
      $or->condition('protocol_set_id', $protocol_set_id);
    }

    $query->condition($or);
  }

  $query->distinct();
}

/**
 * Implements hook_entity_type_build().
 */
function mukurtu_protocol_entity_type_build(array &$entity_types) {
  //$entity_types['file']->setHandlerClass('access', '\Drupal\mukurtu_protocol\MukurtuFileAccessControlHandler');
  if (isset($entity_types['media']) && !$entity_types['media']->hasHandlerClass('query_access')) {
    //\Drupal::logger('mukurtu_protocol')->notice("added media");
    $entity_types['media']->setHandlerClass('query_access', \Drupal\entity\QueryAccess\QueryAccessHandler::class);
  }
}

/**
 * Implements hook_form_alter().
 */
function mukurtu_protocol_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // When we a protocol scope/protocol list pairing, only display the protocol
  // list when the any/all options are selected on the scope.
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  foreach ($protocol_manager->protocolFields as $protocol_field) {
    // Media Library.
    if (isset($form['media'][0]['fields'][$protocol_field['protocol']]) && isset($form['media'][0]['fields'][$protocol_field['scope']])) {
      $form['media'][0]['fields'][$protocol_field['protocol']]['#states'] = [
        'visible' => [':input[name="media[0][fields][' . $protocol_field['scope'] . '][0][value]' . '"]' => [['value' => 'any'], ['value' => 'all']]],
      ];

      // Hide entire protocol fieldset if using protocol inheritance.
      $form['media'][0]['fields']['group_protocols']['#states'] = [
        'visible' => [
          ':input[name="media[0][fields][field_mukurtu_protocol_inherit][target_id]"]' => ['value' => ''],
        ],
      ];
    }

    // Standard entity forms.
    if (isset($form[$protocol_field['protocol']]) && isset($form[$protocol_field['scope']])) {
      $form[$protocol_field['protocol']]['#states'] = [
        'visible' => [
          ':input[name="' . $protocol_field['scope'] . '[0][value]' . '"]' => [['value' => 'any'], ['value' => 'all']],
        ],
      ];

      // Hide entire protocol fieldset if using protocol inheritance.
      $form['group_protocols']['#states'] = [
        'visible' => [
          ':input[name="field_mukurtu_protocol_inherit[target_id]"]' => ['value' => ''],
        ],
      ];

      // Testing ajax.
      if ($protocol_field['scope'] == MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE) {
        $form[$protocol_field['scope']]['widget'][0]['value']['#ajax'] = [
          'callback' => 'mukurtu_protocol_ajax_update_write_protocol_scope',
          'disable-refocus' => FALSE,
          'event' => 'change',
          'wrapper' => 'edit-field-mukurtu-protocol-w-scope-0-value',
        ];
      }

      if ($protocol_field['scope'] == MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE) {
        $read_scope = $form[MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE]['widget'][0]['value']['#default_value'];
        switch ($read_scope) {
          case MUKURTU_PROTOCOL_PERSONAL:
            //$form[$protocol_field['scope']]['widget'][0]['value']['default']['#disabled'] = TRUE;
            $form[$protocol_field['scope']]['widget'][0]['value']['any']['#disabled'] = TRUE;
            $form[$protocol_field['scope']]['widget'][0]['value']['all']['#disabled'] = TRUE;
            break;

          case MUKURTU_PROTOCOL_PUBLIC:
            //$form[$protocol_field['scope']]['widget'][0]['value']['personal']['#disabled'] = TRUE;
            //$form[$protocol_field['scope']]['widget'][0]['value']['default']['#disabled'] = TRUE;
            break;

          case MUKURTU_PROTOCOL_ANY:
            //$form[$protocol_field['scope']]['widget'][0]['value']['personal']['#disabled'] = TRUE;
            break;

          case MUKURTU_PROTOCOL_ALL:
            //$form[$protocol_field['scope']]['widget'][0]['value']['personal']['#disabled'] = TRUE;
            break;
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function mukurtu_protocol_form_media_library_add_form_upload_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (!empty($form['media'])) {
    // Create a checkbox to toggle protocol inherit on first use for media.
    // This doesn't actually DO anything other than obscure the protocol fields.
    // We depend on the default protocol values of 'personal' and the behavior
    // defined in mukurtu_protocol_resolve_new_content_inheritance.
    $form['media'][0]['fields'][MUKURTU_PROTOCOL_FIELD_NAME_INHERIT_FIRST_USE] = [
      '#type' => 'checkbox',
      '#title' => t('Inherit protocol(s) from content'),
      '#default_value' => TRUE,
      '#weight' => 1,
    ];

    // Move protocol widgets below our new checkbox.
    $form['media'][0]['fields'][MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET]['#weight'] = 20;
    $form['media'][0]['fields']['group_protocols']['#weight'] = 30;

    // Hide inheritance element when our simple checkbox is checked.
    $form['media'][0]['fields'][MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET]["widget"]['#states'] = [
      'visible' => [
        ':input[name="field_mukurtu_protocol_inherit_first_use"]' => ['checked' => FALSE],
      ],
    ];

    // Hide protocol elements when our simple checkbox is checked.
    $form['media'][0]['fields']['group_protocols']['#states']['visible'][] = [
      ':input[name="field_mukurtu_protocol_inherit_first_use"]' => ['checked' => FALSE],
    ];
  }
}

/**
 * Update the write protocol scope based on the read scope value.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @return \Drupal\Core\Ajax\AjaxResponse
 *
 */
function mukurtu_protocol_ajax_update_write_protocol_scope(&$form, FormStateInterface $form_state) {
  if (!empty($form_state->getValue(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE)[0]['value'])) {
    $read_scope = $form_state->getValue(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE)[0]['value'];
    $write_scope = $form_state->getValue(MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE)[0]['value'];
    $response = new AjaxResponse();

    // Start from known state, remove all the disabled classes from the radio buttons.
    $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value > div', 'removeClass', ['form-disabled']));

    switch ($read_scope) {
      case MUKURTU_PROTOCOL_PERSONAL:
        // Read scope is personal, the only valid write scope is default.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-default', 'attr', ['disabled', FALSE]));

        // Disable any, all.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-any', 'attr', ['disabled', TRUE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-all', 'attr', ['disabled', TRUE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value > div:nth-child(2)', 'addClass', ['form-disabled']));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value > div:nth-child(3)', 'addClass', ['form-disabled']));

        // Select default.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-default', 'trigger', ['click']));
        return $response;

      case MUKURTU_PROTOCOL_PUBLIC:
        // Read scope is public, the only valid write options are any/all.
        // Disable default.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-default', 'attr', ['disabled', TRUE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value > div:nth-child(1)', 'addClass', ['form-disabled']));

        // Enable any/all.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-any', 'attr', ['disabled', FALSE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-all', 'attr', ['disabled', FALSE]));

        // If write scope was on an invalid selection, select 'any' as the new default.
        if ($write_scope == 'default') {
          $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-any', 'trigger', ['click']));
        }
        return $response;

      case MUKURTU_PROTOCOL_ALL:
      case MUKURTU_PROTOCOL_ANY:
        // Read scope gives a protocol, valid write scopes are default/any/all.
        // Enable default/any/all.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-default', 'attr', ['disabled', FALSE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-any', 'attr', ['disabled', FALSE]));
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-all', 'attr', ['disabled', FALSE]));

        // Select default.
        $response->addCommand(new InvokeCommand('#edit-field-mukurtu-protocol-w-scope-0-value-default', 'trigger', ['click']));
        return $response;
    }

    return $response;
  }
}

/**
 * Implements hook_entity_presave().
 */
function mukurtu_protocol_entity_presave(EntityInterface $entity) {
  $protocol_manager = \Drupal::service('mukurtu_protocol.protocol_manager');
  if ($protocol_manager->hasProtocolFields($entity)) {
    // Check each protocol field for changes for any changes we need to make.
    foreach ($protocol_manager->protocolFields as $protocol_field) {
      //if ($entity->hasField($protocol_field['protocol']) && $entity->hasField($protocol_field['scope'])) {

      // Get the old scope.
      $original_scope = [];
      if (isset($entity->original)) {
        $original_scope = $entity->original->get($protocol_field['scope'])->value;
      }

      $new_scope = $entity->get($protocol_field['scope'])->value;
      if ($original_scope != $new_scope) {
        // The scope has changed from any/all -> public/private. Unset the protocols.
        if (($original_scope == 'any' || $original_scope == 'all') && ($new_scope != 'any' && $new_scope != 'all')) {
          $entity->set($protocol_field['protocol'], NULL);
        }
      }
    }
    //}

    // Compute Community affiliation field.
    $community_protocols = [];
    $community_affiliation = [];

    $read_scope = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_READ_SCOPE)->value;
    $write_scope = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_WRITE_SCOPE)->value;

    // If any write only protocols are set, use those for the
    // community affiliation.
    if ($write_scope == MUKURTU_PROTOCOL_ANY || $write_scope == MUKURTU_PROTOCOL_ALL) {
      $community_protocols = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_WRITE);
    } else {
      // Write protocols not being used, use the read protocols if given.
      if ($read_scope != MUKURTU_PROTOCOL_PERSONAL) {
        $community_protocols = $entity->get(MUKURTU_PROTOCOL_FIELD_NAME_READ);
      }
    }

    // Load each protocol and grab the owning community ID.
    $node_storage = \Drupal::entityTypeManager()->getStorage('node');
    if (!empty($community_protocols)) {
      foreach ($community_protocols as $protocol_ref) {
        $protocol = $node_storage->load($protocol_ref->target_id);
        if ($protocol && $protocol->hasField(MUKURTU_PROTOCOL_FIELD_NAME_COMMUNITY)) {
          $protocol_community = $protocol->get(MUKURTU_PROTOCOL_FIELD_NAME_COMMUNITY)->target_id;
          if ($protocol_community && !in_array($protocol_community, $community_affiliation)) {
            $community_affiliation[] = $protocol_community;
          }
        }
      }
    }

    // Set the new community affiliation.
    if (method_exists($entity, 'hasField') && $entity->hasField(MUKURTU_PROTOCOL_FIELD_NAME_COMMUNITY)) {
      $entity->set(MUKURTU_PROTOCOL_FIELD_NAME_COMMUNITY, $community_affiliation);
    }
  }
}

/**
 * Implements hook_user_login().
 */
function mukurtu_protocol_user_login($account) {
  // This is a dirty little hack to make sure our widgets are configured.
  // Ideally this would be done when the fields are created, but for the
  // fields that are created during install, config is being changed by
  // too many other things and there's not a reliable post-install hook.
  $mukurtu_widgets_set = \Drupal::state()->get('mukurtu_protocol_use_widgets_set', FALSE);
  if (!$mukurtu_widgets_set) {
    mukurtu_protocol_use_custom_protocol_widgets_sitewide();
    \Drupal::state()->set('mukurtu_protocol_use_widgets_set', TRUE);
  }
}

/**
 * Implements hook_file_download().
 */
function mukurtu_protocol_file_download($uri) {
  $account = \Drupal\user\Entity\User::load(\Drupal::currentUser()->id());

  /** @var \Drupal\file\FileInterface[] $files */
  $files = \Drupal::entityTypeManager()->getStorage('file')->loadByProperties(['uri' => $uri]);

  // Find the file by the URI.
  if (count($files)) {
    foreach ($files as $item) {
      if ($item->getFileUri() === $uri) {
        $file = $item;
        break;
      }
    }
  }
  if (!isset($file)) {
    return;
  }

  // Get entities using the file.
  $usage = \Drupal::service('file.usage')->listUsage($file);

  // If the isn't used anywhere, allow.
  // Otherwise we break the Drupal private URI scheme outside of protocols.
  if (empty($usage)) {
    return;
  }

  // Check if the user has view access to any usage of that file.
  foreach ($usage as $type => $entity_types) {
    foreach ($entity_types as $entity_type_id => $entities) {
      $all = \Drupal::entityTypeManager()->getStorage($entity_type_id)->loadMultiple(array_keys($entities));
      foreach ($all as $entity) {
        if ($entity->access('view', $account)) {
          return;
        }
      }
    }
  }

  // At this point we've found entities that this file is used by, and the user
  // has view access to none of them. Deny the download.
  return -1;
}
