<?php

use Drupal\views\ViewExecutable;
use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Component\Serialization\Json;

define("MUKURTU_BROWSE_FIELD_NAME_GEOJSON", 'field_mukurtu_geojson');

/**
 * Implements hook_theme().
 */
function mukurtu_browse_theme($existing, $type, $theme, $path) {
  return [
    'mukurtu_browse' => [
      'variables' => [
        'results' => NULL,
        'facets' => [],
      ],
    ],
    'mukurtu_map_browse' => [
      'variables' => [
        'teasers' => NULL,
        'map' => NULL,
        'facets' => [],
      ],
    ],
  ];
}

/**
 * Implements hook_entity_bundle_create().
 */
function mukurtu_browse_entity_bundle_create($entity_type_id, $bundle) {
  // For any new node that is defined, add the computed fields.
  if ($entity_type_id == 'node') {
    mukurtu_browse_create_computed_fields($entity_type_id, $bundle);
  }
}

/**
 * Create the Mukurtu GeoJSON computed field.
 */
function mukurtu_browse_create_computed_fields($entity_type, $bundle) {
  $entityFieldManager = \Drupal::service('entity_field.manager');
  $fields = $entityFieldManager->getFieldDefinitions($entity_type, $bundle);

  if (!isset($fields[MUKURTU_BROWSE_FIELD_NAME_GEOJSON])) {
    FieldConfig::create([
      'field_name' => MUKURTU_BROWSE_FIELD_NAME_GEOJSON,
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'label' => 'Mukurtu GeoJSON',
    ])->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function mukurtu_browse_node_presave(EntityInterface $entity) {
  $geojson = mukurtu_browse_compute_geojson($entity);
  $entity->set(MUKURTU_BROWSE_FIELD_NAME_GEOJSON, $geojson);
}


/**
 * Compute the GeoJSON for the map browse.
 */
function mukurtu_browse_compute_geojson($entity) {
  $view_builder = \Drupal::entityManager()->getViewBuilder($entity->getEntityTypeId());
  $renderer = \Drupal::service('renderer');
  $coverage = $entity->hasField('field_coverage') ? $entity->get('field_coverage') : NULL;

  // No location data, we're done.
  if (!$coverage) {
    return NULL;
  }

  // Convert WKT to GeoJSON.
  $features = [];
  foreach ($coverage as $location) {
    // Create a new GeoJSON feature.
    $feature = ['type' => 'Feature'];

    // Load the geometry.
    $wkt = $location->getValue()['value'];
    if (!empty($wkt)) {
      $geometry = geoPHP::load($wkt, 'wkt');
      if (is_object($geometry)) {
        $feature['geometry'] = json_decode($geometry->out('json'));

        // Build the pop-up properties.

        $feature['properties'] = [];
        $feature['properties']['name'] = $entity->getTitle();
        $feature['properties']['popup'] = $renderer->renderPlain($view_builder->view($entity, 'map_popup'));
        $features[] = $feature;
      }
    }
  }

  return json_encode($features);
}
