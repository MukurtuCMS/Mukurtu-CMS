<?php

/**
 * @file
 * Provide Mukurtu Collection Type.
 */

use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;

define("MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION", "field_sequence_collection");
define("MUKURTU_COLLECTION_LABEL_SEQUENCE_COLLECTION", "Sequence Collection");
define("MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE", "field_collection_type");
define("MUKURTU_COLLECTION_TYPE_MULTIPAGE", "multipage");
define("MUKURTU_COLLECTION_FIELD_NAME_ITEMS", "field_items_in_collection");
define("MUKURTU_COLLECTION_MULTIPAGE_NAVIGATION_VIEW_MODE", "full");


/**
 * Create the sequence collection field.
 */
function mukurtu_collection_create_sequence_field($entity_type_id, $bundle) {
  $skip_list = ['collection', 'community', 'protocol'];
  if (in_array($bundle, $skip_list)) {
    return;
  }

  $entityFieldManager = \Drupal::service('entity_field.manager');
  $fields = $entityFieldManager->getFieldDefinitions($entity_type_id, $bundle);
  if (!isset($fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION])) {
    FieldConfig::create([
      'field_name' => MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION,
      'entity_type' => $entity_type_id,
      'bundle' => $bundle,
      'label' => MUKURTU_COLLECTION_LABEL_SEQUENCE_COLLECTION,
      'description' => '',
      'required' => FALSE,
      'settings' => [
        'handler' => 'default:node',
        'handler_settings' => [
          'target_bundles' => ['collection'],
        ],
      ],
    ])->save();
  }
}

/**
 * Implements hook_entity_bundle_create().
 */
function mukurtu_collection_entity_bundle_create($entity_type_id, $bundle) {
  // For any new node that is defined, add the sequence collection field.
  if ($entity_type_id == 'node') {
    mukurtu_collection_create_sequence_field($entity_type_id, $bundle);
  }
}

/**
 * Implements hook_entity_insert().
 */
function mukurtu_collection_entity_insert(EntityInterface $entity) {
  mukurtu_collection_multipage_sync_relationship($entity);
}

/**
 * Implements hook_entity_update().
 */
function mukurtu_collection_entity_update(EntityInterface $entity) {
  mukurtu_collection_multipage_sync_relationship($entity);
}

/**
 * Implements hook_entity_delete().
 */
function mukurtu_collection_entity_delete(EntityInterface $entity) {
  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_ITEMS)) {
    // Set the collection to empty and request a relationship sync.
    // This will delete all the item level references to the collection.
    $entity->set(MUKURTU_COLLECTION_FIELD_NAME_ITEMS, []);
    mukurtu_collection_multipage_sync_relationship($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function mukurtu_collection_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  if ($view_mode === 'multipage_navigation' || $view_mode === 'multipage_item') {
    if (isset($build['title'])) {
      unset($build['title']);
    }
  }

  if ($entity->getEntityTypeId() == 'node') {
    // Collections.
    if ($entity->bundle() == 'collection' && $entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)) {
      $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;
      if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
        // Add in the multipage navigation field.
        $temp = $build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS];
        unset($build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS]);
        $build['field_multipage_navigation'] = $entity->{MUKURTU_COLLECTION_FIELD_NAME_ITEMS}->view('multipage_navigation');
        $build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS] = $temp;
      }
    }
  }
}

/**
 * Implements hook_entity_view_mode_alter().
 */
function mukurtu_collection_entity_view_mode_alter(&$view_mode, EntityInterface $entity, $context) {
  if ($entity->getEntityTypeId() != 'node') {
    return;
  }

  // Alter view modes for collections.
  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE) && $entity->bundle() == 'collection') {
    $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;
    if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
      if ($view_mode == 'full') {
        // Display "full" mode multipage collections in "multipage_item" mode.
        $view_mode = 'multipage_item';
      }
    }
  }

  // Any full view content that is a member of a multipage collection.
  if ($view_mode ==  'full' && $entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION)) {
    $collections = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION)->referencedEntities();
    $collection = $collections[0] ?? NULL;
    if ($collection) {
      $view_mode = 'multipage_full';
    }
  }
}

/**
 * Update the item references for a multi-page collection.
 */
function mukurtu_collection_multipage_sync_relationship(EntityInterface $entity) {
  // Multipage collections only work with nodes.
  if ($entity->getEntityTypeId() != 'node') {
    return;
  }

  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE) && $entity->bundle() == 'collection') {
    $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;

    // Collection is a multi-page item, check if any contained items
    // need to be updated.
    if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
      $old_items = [];

      // Items can only be in a single multi-page collection at a time.
      // Do a site-wide query to catch broken relationships.
      $query = \Drupal::entityQuery('node');
      $query->condition(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION, $entity->id());
      $old_items = $query->execute();

      $new_items = mukurtu_core_flatten_entity_ref_field($entity, MUKURTU_COLLECTION_FIELD_NAME_ITEMS);
      $items_to_remove = array_diff($old_items, $new_items);
      $items_to_add = array_diff($new_items, $old_items);

      $fn_args = [
        'fieldname' => MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION,
        'target_id' => $entity->id(),
      ];
      // Remove old items from the multi-page collection.
      if (!empty($items_to_remove)) {
        mukurtu_core_entity_batch_operation('mukurtu_core_batch_remove_entity_reference', ['node' => $items_to_remove], $fn_args);
      }
      // Add new items from the multi-page collection.
      if (!empty($items_to_add)) {
        mukurtu_core_entity_batch_operation('mukurtu_core_batch_add_entity_reference', ['node' => $items_to_add], $fn_args);
      }
    }
  }
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function mukurtu_collection_entity_bundle_field_info_alter(&$fields, EntityTypeInterface $entity_type, $bundle) {
  // Attach our contraint to the sequence collection field.
  if (isset($fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION])) {
    $fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION]->addConstraint('ValidSequenceCollection', []);
  }
}

/**
 * Implements hook_slick_settings_alter().
 */
function mukurtu_collection_slick_settings_alter(array &$build, $items) {
  $id = \Drupal::routeMatch()->getRawParameter('node');

  $options = &$build['optionset'];

  $page = 0;

  // Select the current node in the slick slider.
  if ($id) {
    $refs = $items->referencedEntities();
    foreach ($refs as $ref) {
      if ($id == $ref->id()) {
        $options->setSetting('initialSlide', $page);
        continue;
      }
      $page++;
    }
  }
}
