<?php

/**
 * @file
 * Provide Mukurtu Collection Type.
 */

use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Form\FormStateInterface;

define("MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION", "field_sequence_collection");
define("MUKURTU_COLLECTION_LABEL_SEQUENCE_COLLECTION", "Sequence Collection");
define("MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE", "field_collection_type");
define("MUKURTU_COLLECTION_TYPE_MULTIPAGE", "multipage");
define("MUKURTU_COLLECTION_FIELD_NAME_ITEMS", "field_items_in_collection");
define("MUKURTU_COLLECTION_MULTIPAGE_NAVIGATION_VIEW_MODE", "full");


/**
 * Create the sequence collection field.
 */
function mukurtu_collection_create_sequence_field($entity_type_id, $bundle) {
  $skip_list = ['collection', 'community', 'protocol'];
  if (in_array($bundle, $skip_list)) {
    return;
  }

  $entityFieldManager = \Drupal::service('entity_field.manager');
  $fields = $entityFieldManager->getFieldDefinitions($entity_type_id, $bundle);
  if (!isset($fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION])) {
    FieldConfig::create([
      'field_name' => MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION,
      'entity_type' => $entity_type_id,
      'bundle' => $bundle,
      'label' => MUKURTU_COLLECTION_LABEL_SEQUENCE_COLLECTION,
      'description' => '',
      'required' => FALSE,
      'settings' => [
        'handler' => 'default:node',
        'handler_settings' => [
          'target_bundles' => ['collection'],
        ],
      ],
    ])->save();
  }
}

/**
 * Implements hook_entity_bundle_create().
 */
function mukurtu_collection_entity_bundle_create($entity_type_id, $bundle) {
  // For any new node that is defined, add the sequence collection field.
  if ($entity_type_id == 'node') {
    mukurtu_collection_create_sequence_field($entity_type_id, $bundle);
  }
}

/**
 * Implements hook_entity_insert().
 */
function mukurtu_collection_entity_insert(EntityInterface $entity) {
  mukurtu_collection_multipage_sync_relationship($entity);
}

/**
 * Implements hook_entity_update().
 */
function mukurtu_collection_entity_update(EntityInterface $entity) {
  mukurtu_collection_multipage_sync_relationship($entity);
}

/**
 * Implements hook_entity_delete().
 */
function mukurtu_collection_entity_delete(EntityInterface $entity) {
  if ($entity->getEntityTypeId() !== 'node') {
    return;
  }

  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_ITEMS)) {
    // Set the collection to empty and request a relationship sync.
    // This will delete all the item level references to the collection.
    $entity->set(MUKURTU_COLLECTION_FIELD_NAME_ITEMS, []);
    mukurtu_collection_multipage_sync_relationship($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function mukurtu_collection_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  // Don't display the real title field for multipage view modes.
  if (substr($view_mode, 0, 10) === 'multipage_') {
    if (isset($build['title'])) {
      unset($build['title']);
    }
  }

  if ($entity->getEntityTypeId() == 'node') {
    // Collections.
    if ($entity->bundle() == 'collection' && $entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)) {
      $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;
      if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
        // Add in the multipage navigation field.
        $temp = $build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS] ?? [];
        if (!empty($temp)) {
          unset($build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS]);
        }

        if ($display->getComponent(MUKURTU_COLLECTION_FIELD_NAME_ITEMS)) {
          $build['field_multipage_navigation'] = $entity->{MUKURTU_COLLECTION_FIELD_NAME_ITEMS}->view('multipage_navigation');
          $build[MUKURTU_COLLECTION_FIELD_NAME_ITEMS] = $temp;
        }
      }
    }
  }
}

/**
 * Implements hook_entity_view_mode_alter().
 */
function mukurtu_collection_entity_view_mode_alter(&$view_mode, EntityInterface $entity, $context) {
  if ($entity->getEntityTypeId() != 'node') {
    return;
  }

  // Alter view modes for collections.
  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE) && $entity->bundle() == 'collection') {
    $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;
    if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
      if ($view_mode == 'full') {
        // Display "full" mode multipage collections in "multipage_item" mode.
        $view_mode = 'multipage_item';
      }
    }
  }

  // Any full view content that is a member of a multipage collection.
  if ($view_mode == 'full' && $entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION)) {
    $collections = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION)->referencedEntities();
    $collection = $collections[0] ?? NULL;
    if ($collection) {
      $view_mode = 'multipage_full';
    }
  }
}

/**
 * Update the item references for a multi-page collection.
 */
function mukurtu_collection_multipage_sync_relationship(EntityInterface $entity) {
  // Multipage collections only work with nodes.
  if ($entity->getEntityTypeId() != 'node') {
    return;
  }

  if ($entity->hasField(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE) && $entity->bundle() == 'collection') {
    $collection_type = $entity->get(MUKURTU_COLLECTION_FIELD_NAME_COLLECTION_TYPE)->value;

    // Collection is a multi-page item, check if any contained items
    // need to be updated.
    if ($collection_type == MUKURTU_COLLECTION_TYPE_MULTIPAGE) {
      $old_items = [];

      // Items can only be in a single multi-page collection at a time.
      // Do a site-wide query to catch broken relationships.
      $query = \Drupal::entityQuery('node');
      $query->condition(MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION, $entity->id());
      $old_items = $query->execute();

      $new_items = mukurtu_core_flatten_entity_ref_field($entity, MUKURTU_COLLECTION_FIELD_NAME_ITEMS);
      $items_to_remove = array_diff($old_items, $new_items);
      $items_to_add = array_diff($new_items, $old_items);

      $fn_args = [
        'fieldname' => MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION,
        'target_id' => $entity->id(),
      ];
      // Remove old items from the multi-page collection.
      if (!empty($items_to_remove)) {
        mukurtu_core_entity_batch_operation('mukurtu_core_batch_remove_entity_reference', ['node' => $items_to_remove], $fn_args);
      }
      // Add new items from the multi-page collection.
      if (!empty($items_to_add)) {
        mukurtu_core_entity_batch_operation('mukurtu_core_batch_add_entity_reference', ['node' => $items_to_add], $fn_args);
      }
    }
  }
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function mukurtu_collection_entity_bundle_field_info_alter(&$fields, EntityTypeInterface $entity_type, $bundle) {
  // Attach our contraint to the sequence collection field.
  if (isset($fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION])) {
    $fields[MUKURTU_COLLECTION_FIELD_NAME_SEQUENCE_COLLECTION]->addConstraint('ValidSequenceCollection', []);
  }
}

/**
 * Implements hook_slick_settings_alter().
 */
function mukurtu_collection_slick_settings_alter(array &$build, $items) {
  $id = \Drupal::routeMatch()->getRawParameter('node');

  $options = &$build['optionset'];

  $page = 0;

  // Select the current node in the slick slider.
  if ($id) {
    $refs = $items->referencedEntities();
    foreach ($refs as $ref) {
      if ($id == $ref->id()) {
        $options->setSetting('initialSlide', $page);
        continue;
      }
      $page++;
    }
  }
}


/**
 * Implements hook_form_alter().
 */
function mukurtu_collection_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Only run on node forms.
  if (strpos($form_id, 'node_') === 0 && strpos($form_id, '_edit_form') > 0) {
    $args = $form_state->getBuildInfo()['args'];

    // Are there any mukurtu_collection specific arguments to handle?
    if (!empty($args) && isset($args[0]['mukurtu_collection']['submit'])) {
      // We want to add this node to the target collection after the node form is submitted.
      // Add the collection ID to the form.
      $form['mukurtu_collection_target'] = [
        '#type' => 'hidden',
        '#value' => $args[0]['mukurtu_collection']['target'],
      ];

      // Attach our custom submit handler that will run after the default handler.
      $form['actions']['submit']['#submit'][] = $args[0]['mukurtu_collection']['submit'][0];
    }
  }
}

/**
 * Submit handler for node create form to add node to collection after save.
 */
function mukurtu_collection_multipage_add_page_form_submit(array &$form, FormStateInterface $form_state) {
  // Get the collection ID, this is set in mukurtu_collection_form_alter.
  $collection_id = $form_state->getValue('mukurtu_collection_target');
  if ($collection_id) {
    $collection = \Drupal::entityTypeManager()->getStorage('node')->load($collection_id);
    if ($collection && $collection->access('update')) {
      // Add the node to the collection's items field.
      $items = mukurtu_core_flatten_entity_ref_field($collection, MUKURTU_COLLECTION_FIELD_NAME_ITEMS);
      $items[] = $form_state->getformObject()->getEntity()->id();
      $collection->set(MUKURTU_COLLECTION_FIELD_NAME_ITEMS, $items);
      $collection->save();
    }
  }
}

/**
 * Submit handler for node create form for multipage item creation.
 */
function mukurtu_collection_multipage_create_multipage_form_submit(array &$form, FormStateInterface $form_state) {
  // The nid of the node the user is converting into a brand new MPI.
  $nid = $form_state->getValue('mukurtu_collection_target');

  if ($nid) {
    $node = \Drupal::entityTypeManager()->getStorage('node')->load($nid);
    if ($node && $node->access('update')) {
      // The ID of the new MPI collection.
      $new_multipage_collection_id = $form_state->getformObject()->getEntity()->id();

      // Have the original item (first page) inherit protocols from the collection.
      // The protocols of the collection were initially copied from the node during creation.
      $node->set(MUKURTU_PROTOCOL_FIELD_NAME_INHERITANCE_TARGET, $new_multipage_collection_id);
      $node->save();
    }
  }
}
